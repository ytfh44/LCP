# LCP (Language Context Provider) 开发路线图

## 项目简介

LCP 是一个基于 MCP (Model Context Protocol) 标准的中间件服务，旨在将 IDE 后端能力（LSP 用于静态分析，DAP 用于动态调试）封装为 LLM 可理解、无状态、原子化的工具集。LCP 的核心使命是解决 LLM 在代码理解和调试过程中的上下文劣化和交互阻塞问题，通过语义索引替代全文读取降低 Token 消耗，通过原子化 RPC 调用消除 Agent 被挂起的风险。

## 系统架构

```mermaid
graph TD
    User[LLM / Agent] -->|MCP Request| LCP_Server
    
    subgraph "LCP Core (Node.js)"
        LCP_Server[MCP Server Handler]
        Router[Session Router]
        
        subgraph "Static Analysis Engine"
            LSP_Mgr[LSP Manager]
            LSP_Client[LSP Client Implementation]
            VFS[Virtual File System / Cache]
            DiagnosticMap[Diagnostic Cache]
        end
        
        subgraph "Dynamic Debug Engine"
            DAP_Mgr[DAP Session Manager]
            DAP_Client[DAP Client & State Machine]
            Event_Bus[Event Bus (Wait-Notify)]
            BreakpointMap[Breakpoint Cache]
        end
        
        subgraph "Supporting Services"
            SessionStore[Session Store]
            ErrorHandler[Error Handler & Recovery]
            FileResolver[File Path Resolver]
        end
    end
    
    LSP_Client -->|JSON-RPC via Stdio| Pyright[Ext: Pyright]
    LSP_Client -->|JSON-RPC via Stdio| Gopls[Ext: Gopls]
    LSP_Client -->|JSON-RPC via Stdio| Clangd[Ext: Clangd]
    LSP_Client -->|JSON-RPC via Stdio| TsServer[Ext: TSServer]
    
    DAP_Client -->|DAP Protocol| DebugPy[Ext: DebugPy]
    DAP_Client -->|DAP Protocol| GDB_Adapter[Ext: OpenDebugAD7]
    DAP_Client -->|DAP Protocol| NodeDebug[Ext: Node Debug]
```

## 实现顺序与重要度

### Phase 1: MVP (Python Focus) - 最高优先级

**核心功能**：

1. **集成 LSP 和 DAP 服务**
   - 集成 `pyright` 作为 Python 语言的 LSP 服务
   - 集成 `debugpy` 作为 Python 语言的 DAP 服务
   - 实现 LSP 服务的生命周期管理（启动、初始化、关闭）
   - 实现 DAP 服务的生命周期管理（启动、初始化、关闭）
   - 使用 `execa` 库监控服务进程状态，确保服务稳定运行

2. **实现基础静态分析工具**
   - **`lcp_get_outline`**: 获取文件骨架和符号信息
     - 调用 LSP `textDocument/documentSymbol` 获取符号树
     - 将符号树转换为扁平化的 JSON 列表，包含 `name`, `kind`, `range`, `children` 等字段
     - 支持模糊匹配文件名，自动纠正路径错误
   - **`lcp_read_symbol`**: 精准读取函数或类的代码
     - 先通过 `textDocument/documentSymbol` 找到符号对应的 `range`
     - 再读取文件内容，仅返回该 `range` 内的文本
     - 支持模糊匹配符号名称，自动纠正符号错误
     - 对超长符号代码自动截断，保留关键上下文
   - **`lcp_get_diagnostics`**: 获取编译器报错和警告
     - 维护 `DiagnosticMap` 缓存，实时更新 LSP 推送的诊断信息
     - 支持按文件过滤诊断信息
     - 提供清晰的错误等级（error/warning/info）和详细的错误信息

3. **实现基础调试工具**
   - **`lcp_debug_launch`**: 启动调试会话
     - 根据程序类型自动选择合适的 Debug Adapter
     - 支持传递程序参数和环境变量
     - 自动停在程序入口点，返回会话 ID 和初始状态
   - **`lcp_add_breakpoint`**: 添加断点
     - 支持行级断点，验证断点位置的有效性
     - 在内存中维护 `BreakpointMap`，管理所有断点
     - 向 Debug Adapter 发送 `setBreakpoints` 请求，同步断点状态
   - **`lcp_debug_step`**: 原子化调试操作
     - 支持 `next`、`stepIn`、`stepOut`、`continue` 四种调试动作
     - 实现事件栅栏机制，等待调试停止事件后返回结果
     - 自动获取当前堆栈、局部变量和执行状态
     - 实现超时保护机制，防止调试会话卡死
   - **`lcp_debug_evaluate`**: 在当前上下文执行表达式
     - 调用 DAP `evaluate` 请求，执行用户提供的表达式
     - 返回表达式的执行结果、类型和变量引用
     - 支持在不同作用域（全局、局部、当前帧）执行表达式

4. **实现会话管理和资源释放**
   - 使用 `Map<SessionID, Session>` 存储所有会话状态
   - 实现会话超时机制，自动清理长时间未活动的会话
   - 支持手动关闭会话，释放相关资源
   - 确保 LSP 和 DAP 服务在会话结束后正确关闭

**技术目标**：
- 支持 Python 3.8+ 版本
- 实现与 MCP 协议的完整集成
- 支持基本的错误处理和容错机制
- 提供清晰、友好的错误信息

**正确性需求**：
- 静态分析工具返回的符号信息必须与实际代码完全一致
- 符号读取功能必须准确返回指定符号的完整代码，无遗漏或多余内容
- 诊断信息必须准确反映编译器的实际报错和警告
- 调试工具必须准确控制程序的执行流程
- 断点功能必须在指定位置准确触发
- 调试状态返回必须与程序实际执行状态完全一致
- 表达式求值结果必须与程序实际执行结果一致
- 会话管理必须确保资源正确释放，无内存泄漏

**验收标准**：
- 能够成功启动调试会话并执行所有基本调试操作
- 能够准确获取文件大纲和符号信息
- 能够精确读取指定符号的代码内容
- 能够获取准确的编译器诊断信息
- 能够正确添加、管理和触发断点
- 能够准确执行各种调试步骤
- 能够在当前上下文正确执行表达式求值
- 能够处理常见错误情况，返回友好、明确的错误信息

### Phase 2: 多语言支持 - 高优先级

**核心功能**：

1. **引入多种语言的 LSP 和 DAP 服务**
   - 集成 `gopls` 作为 Go 语言的 LSP 服务
   - 集成 `clangd` 作为 C/C++ 语言的 LSP 服务
   - 集成 `tsserver` 作为 TypeScript/JavaScript 语言的 LSP 服务
   - 集成相应的 DAP 服务，支持多种语言的调试

2. **实现 LCP Router**
   - 根据文件扩展名自动识别语言类型
   - 根据语言类型自动选择合适的 LSP 服务
   - 实现 LSP 服务的动态启动和切换
   - 支持同一项目中多种语言的混合使用

3. **增强调试功能**
   - 支持条件断点，根据表达式结果决定是否中断
   - 支持日志断点，在断点位置输出日志而不中断执行
   - 实现断点的启用/禁用功能
   - 支持断点的批量管理

4. **实现符号引用查找功能**
   - **`lcp_find_references`**: 全项目查找符号引用
     - 先通过 `textDocument/definition` 锁定符号的具体定义
     - 再通过 `textDocument/references` 获取所有引用位置
     - 读取每个引用点的上下文代码片段
     - 返回结构化的引用列表，包含文件路径、行号、代码片段和上下文

5. **支持会话状态恢复**
   - 实现会话状态的序列化和反序列化
   - 支持调试会话的暂停和恢复
   - 支持断点状态的持久化存储
   - 确保会话恢复后状态与恢复前完全一致

**技术目标**：
- 支持 4 种主流语言：Python, Go, C/C++, TypeScript
- 实现高级错误处理和自我修复机制
- 支持并发处理多个调试会话
- 实现语言服务的按需加载和资源优化

**正确性需求**：
- LCP Router 必须根据文件扩展名准确选择对应的 LSP 服务
- 多语言混合项目中，不同语言的符号信息必须正确隔离和处理
- 条件断点必须根据表达式的实际结果准确触发
- 日志断点必须在指定位置准确输出日志，不影响程序执行
- 符号引用查找必须返回所有实际引用，无遗漏或误报
- 会话状态恢复后，必须与恢复前的状态完全一致
- 并发会话之间必须完全隔离，互不影响

**验收标准**：
- 能够自动识别不同语言的文件，并选择正确的 LSP 服务
- 能够在同一项目中处理多种语言的文件
- 能够正确设置和触发条件断点
- 能够正确设置和使用日志断点
- 能够准确查找符号的所有引用位置
- 能够成功暂停和恢复调试会话
- 能够处理多个并发调试会话，无相互干扰
- 能够恢复崩溃的 Debug Adapter 会话，保持状态一致性

### Phase 3: 高级特性 - 中优先级

**核心功能**：

1. **实现热重载调试**
   - **Hot Reload Debugging**: 允许在调试过程中修改代码并热重载
   - 监听文件变更事件，自动检测代码修改
   - 向 Debug Adapter 发送代码更新请求
   - 支持在不重启调试会话的情况下应用代码变更
   - 保持当前调试状态，继续执行修改后的代码

2. **实现反向调试功能**
   - **Reverse Debugging**: 允许 LLM "回退一步"，查看历史执行状态
   - 集成支持反向调试的 Debug Adapter
   - 实现 `reverse-next`、`reverse-stepIn`、`reverse-stepOut` 等反向调试命令
   - 支持查看程序执行的历史状态和变量值
   - 允许在历史执行点设置断点，回退到指定位置

3. **实现智能代码补全**
   - **智能代码补全**: 基于 LSP 的 `completionItem/resolve` 提供智能代码补全
   - 支持根据上下文提供准确的代码补全建议
   - 支持补全函数、变量、类、方法等多种符号
   - 提供补全项的详细信息，包括文档、参数签名等
   - 支持补全项的筛选和排序

4. **实现代码重构支持**
   - 支持重命名符号，自动更新所有引用位置
   - 支持提取函数，将选中代码块提取为独立函数
   - 支持提取变量，将复杂表达式提取为变量
   - 支持内联函数和内联变量
   - 支持代码格式化，保持代码风格一致性

**技术目标**：
- 实现高级调试功能，提升调试效率
- 支持代码生成和重构，增强开发辅助能力
- 提高 AI 辅助开发的智能性和准确性
- 实现更丰富的代码理解和操作能力

**正确性需求**：
- 热重载功能必须正确应用代码修改，不破坏程序执行状态
- 反向调试必须准确恢复历史执行状态，变量值和执行位置必须与历史一致
- 智能代码补全必须提供准确、相关的补全建议，无错误或无关建议
- 代码重构功能必须保持代码的语义正确性，不引入语法错误或逻辑错误
- 重命名功能必须更新所有引用位置，无遗漏或误改
- 提取功能必须保持代码的逻辑完整性，不改变原有功能

**验收标准**：
- 能够在调试过程中修改代码并成功热重载
- 热重载后程序执行状态保持一致，功能正常
- 能够执行反向调试操作，查看历史执行状态
- 反向调试能够准确恢复历史变量值和执行位置
- 能够提供准确、相关的代码补全建议
- 补全建议包含完整的文档和参数信息
- 能够成功执行各种代码重构操作
- 重构后的代码语义正确，功能与重构前一致
- 重命名操作能够更新所有引用位置，无遗漏

### Phase 4: 性能优化与扩展 - 低优先级

**核心功能**：

1. **实现分布式架构**
   - 支持水平扩展，部署多个 LCP 实例
   - 实现负载均衡，分发请求到不同实例
   - 支持会话的跨实例迁移
   - 实现分布式状态管理

2. **优化 LSP 和 DAP 通信**
   - 实现高效的 JSON-RPC 通信机制
   - 优化请求和响应的序列化/反序列化
   - 实现批量请求处理，减少通信开销
   - 优化事件处理机制，提高响应效率

3. **实现缓存机制**
   - 缓存 LSP 响应结果，提高重复请求的处理速度
   - 实现缓存失效机制，确保缓存数据的准确性
   - 支持缓存策略配置，根据需求调整缓存行为
   - 实现符号信息、诊断信息等数据的缓存

4. **支持插件系统**
   - 实现插件加载机制，支持动态加载和卸载插件
   - 定义插件 API，允许扩展新的 LSP 和 DAP 服务
   - 支持插件配置和管理
   - 提供插件开发文档和示例

**技术目标**：
- 支持大规模项目的高效处理
- 实现灵活的扩展机制，支持新的语言和工具
- 提高系统的可靠性和可用性
- 实现资源的高效利用和优化

**正确性需求**：
- 分布式架构必须保证请求的正确路由和处理
- 跨实例迁移必须保持会话状态的一致性
- 缓存机制必须确保缓存数据与实际数据的一致性
- 缓存失效机制必须及时更新失效数据
- 插件系统必须保证插件的正确加载和执行
- 插件 API 必须提供稳定、可靠的扩展能力

**验收标准**：
- 能够部署多个 LCP 实例，实现负载均衡
- 能够成功迁移会话到不同实例，保持状态一致
- 缓存机制能够提高重复请求的处理效率
- 缓存数据能够及时更新，保持准确性
- 能够成功加载和卸载插件
- 插件能够正确扩展 LCP 的功能
- 插件 API 提供完整的扩展能力

## 实现顺序说明

1. **Phase 1**：作为 MVP 版本，优先实现 Python 语言的核心功能，确保基本可用性和正确性。这是整个项目的基础，必须严格保证功能的准确性和稳定性。

2. **Phase 2**：在 MVP 基础上扩展支持多种主流语言，提高工具的通用性。重点实现语言自动识别、多语言支持和会话状态恢复等功能，确保在复杂场景下的正确性。

3. **Phase 3**：添加高级特性，增强工具的功能性和易用性。重点实现热重载调试、反向调试、智能代码补全和代码重构等高级功能，进一步提高开发效率和准确性。

4. **Phase 4**：优化性能和扩展性，支持大规模项目和高并发场景。重点实现分布式架构、通信优化、缓存机制和插件系统，确保系统在复杂环境下的可靠性和可扩展性。

## 重要度说明

- **最高优先级**：必须实现的核心功能，直接影响项目的基本可用性和正确性。这些功能是项目的基础，必须严格保证质量和准确性。

- **高优先级**：重要的扩展功能，影响项目的通用性和适用范围。这些功能能够扩展项目的应用场景，提高工具的实用性。

- **中优先级**：增强功能，提升用户体验和工具价值。这些功能能够提高开发效率，增强工具的智能性和易用性。

- **低优先级**：优化和扩展功能，提高项目的性能和可扩展性。这些功能能够支持更大规模的项目和更复杂的场景，提高系统的可靠性和可用性。

## 核心设计原则

1. **正确性优先**：所有功能必须保证结果的准确性，这是 LCP 的核心价值所在。

2. **无状态设计**：对外暴露的 API 必须是无状态的，便于 LLM/Agent 调用。

3. **原子化操作**：将复杂的 IDE 操作拆分为原子化的 API，便于 LLM/Agent 理解和使用。

4. **容错设计**：实现完善的错误处理和容错机制，确保系统在各种异常情况下能够稳定运行。

5. **用户友好**：提供清晰、友好的错误信息和返回结果，便于 LLM/Agent 理解和处理。

6. **可扩展设计**：采用模块化设计，支持未来扩展更多语言和功能。

7. **资源优化**：实现高效的资源管理，避免资源泄漏和浪费。